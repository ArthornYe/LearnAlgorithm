package Stack.单调栈.P862;

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;

class Solution {
    public int shortestSubarray(int[] A, int K) {
        //构造前缀和数组
        int n=A.length,min=Integer.MAX_VALUE;
        int[] preSum=new int[n+1];
        for (int i = 1; i < preSum.length; i++) {
            preSum[i]=preSum[i-1]+A[i-1];
        }
        //我们的目标是找到当前前缀和位置左边第一个满足条件的位置 (这里可以想到用单调栈))
        Deque<Integer> deque=new LinkedList<>();
        for (int i = 0; i < preSum.length; i++) {
            while(!deque.isEmpty() && preSum[i]-preSum[deque.peekLast()]<K){
                deque.pollLast();
            }
            //当前栈顶元素满足条件
            if(!deque.isEmpty()){
                min=Math.min(min, i-deque.peekLast());
            }
            deque.offerLast(i);
        }
        return min==Integer.MAX_VALUE?-1:min;
    }

    public static void main(String[] args) {
        System.out.println(new Solution().shortestSubarray(new int[]{2, -1, 2}, 3));
        String productIds = "4601,4659,6235,6012,4599,4647,5741,4508,4690,5214,5491,5723,5986,4724,4697,4788,5890,4718,4723,5030,5321,5625,5928,5999,6002,4857,4776,4817,5219,4647,4720,5823,5219,5373,5879,4702,4717,5454,4687,5219,4601,4904,5214,6198,6211,6212,6276,6277,5836,6278,6314,6322,6279,6312,6322,6360,6195,6196,6197,4507,4748,4850,4852,4853,5679,5990,6193,6194,6204,6208,6224,6232,6234,6378,6692,5680,5987,6271,6272,6273,6275,6311,6315,6317,6323,6476,6318,6370,6424,6736,5383,6756,5237,5931,6003,6243,6647,5823,6250,6254,6372,6743,6744,6790,4888,6245,6324,6349,6371,6700,4851,5932,6276,5530,5369,6799,6424,4614,4642,5394,5896,6300,6309,6353,6362,6620,5418,5219,6322,6424,6322,4645,4839,4840,4851,5837,5841,5842,5844,5845,5846,5847,5848,5851,6680,6815,5710,6313,5494,5823,5908,5886,5887,5925,5386,4569,4736,4857,5219,5418,6544,6636,6322,4493,4505,4686,4696,4707,4751,4772,4779,4848,5028,5029,5626,5736,5739,5741,5742,5749,5807,5809,5811,5812,5832,5849,5874,5876,5879,5880,5891,5892,5977,5993,5998,6004,6227,6234,6251,6256,6308,6364,6366,6367,6526";
        List<Integer> productIdList= new ArrayList<>();
        productIdList = Arrays.stream(productIds.split(",")).map(Integer::valueOf).collect(Collectors.toList());

        String productSums = "1.00,1.00,37.00,1.00,1.00,1.00,1.00,1.00,2.00,2.00,6.00,2.00,1.00,1.00,1.00,4.00,1.00,1.00,1.00,1920.00,10.00,1.00,1.00,1.00,1.00,1.00,1.00,2.00,17.00,1.00,1.00,2.00,1.00,1.00,1.00,1.00,1.00,8.00,16.00,13.00,4.00,4.00,2.00,60.00,1.00,3.00,1.00,1.00,300.00,1.00,1.00,100.00,1.00,1.00,1.00,4.00,1.00,100.00,100.00,100.00,10.00,137.00,5.00,7.00,1.00,30.00,47.00,1.00,5.00,60.00,1.00,1.00,1.00,3.00,2.00,30.00,70.00,10000.00,1.00,1.00,2.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,3.00,1.00,1.00,1.00,1.00,200.00,3.00,1.00,2.00,1.00,5.00,1.00,1.00,1.00,1.00,1.00,1.00,4.00,2.00,9.00,1.00,2.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,2.00,1.00,3.00,3.00,1.00,15.00,50.00,50.00,1000.00,50.00,50.00,5000.00,1000.00,1.00,200.00,15.00,100.00,100.00,9.00,100.00,1.00,20.00,2.00,15.00,500.00,10.00,60.00,2.00,1.00,1.00,1.00,2.00,1.00,1.00,1.00,1.00,1.00,1.00,2.00,3.00,3.00,9.00,10.00,1.00,1.00,8.00,2.00,6.00,2.00,4.00,2.00,1.00,2.00,2.00,1.00,2.00,2.00,2.00,1.00,9.00,4.00,1.00,5.00,2000.00,2.00,2.00,1.00,1.00,1.00,10.00,1.00,20.00,6.00,9.00,80.00,100.00,400.00,19.00,200.00,2.00,636.00,1000.00,700.00,3.00,20.00,50.00";
        List<BigDecimal> productSumList=new ArrayList<>();
        productSumList = Arrays.stream(productSums.split(",")).map(BigDecimal::new).collect(Collectors.toList());
        for (int i = 0; i < productIdList.size(); i++) {
            productSumList.get(i);
        }
        Integer integer=new Integer(96);
        int size=96;
        System.out.println(integer==size);
        productSumList.get(191);
        System.out.println();
    }
}